/*
 * Copyright (c) 2026, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2026, NTT DATA.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 *
 */

package sun.jvm.hotspot.debugger.linux;

import sun.jvm.hotspot.debugger.Address;
import sun.jvm.hotspot.debugger.ThreadProxy;
import sun.jvm.hotspot.debugger.UnalignedAddressException;
import sun.jvm.hotspot.debugger.UnmappedAddressException;
import sun.jvm.hotspot.debugger.cdbg.CFrame;
import sun.jvm.hotspot.debugger.cdbg.ClosestSymbol;
import sun.jvm.hotspot.debugger.cdbg.basic.BasicCFrame;
import sun.jvm.hotspot.runtime.VM;

public class DwarfCFrame extends BasicCFrame {

    private Address sp;
    private Address fp;
    private Address pc;
    private Address cfa;
    private LinuxDebugger linuxDbg;
    private DwarfParser dwarf;
    private boolean use1ByteBeforeToLookup;

    /**
     * @return DwarfParser instance for the PC, null if native library relates to the pc not found.
     * @throws DebuggerException if DWARF processing is failed.
     *         For example: pc is not covered in this DWARF, Common Information Entry (CIE) has
     *         language personality routine and/or Language Data Area (LSDA).
     */
    protected static DwarfParser createDwarfParser(LinuxDebugger linuxDbg, Address pc) {
        Address libptr = linuxDbg.findLibPtrByAddress(pc);
        if (libptr != null) {
            DwarfParser dwarf = new DwarfParser(libptr);
            dwarf.processDwarf(pc);
            return dwarf;
        }
        return null;
    }

    protected DwarfCFrame(LinuxDebugger linuxDbg, Address sp, Address fp, Address cfa, Address pc, DwarfParser dwarf) {
        this(linuxDbg, sp, fp, cfa, pc, dwarf, false);
    }

    protected DwarfCFrame(LinuxDebugger linuxDbg, Address sp, Address fp, Address cfa, Address pc, DwarfParser dwarf, boolean use1ByteBeforeToLookup) {
        super(linuxDbg.getCDebugger());
        this.sp = sp;
        this.fp = fp;
        this.cfa = cfa;
        this.pc = pc;
        this.linuxDbg = linuxDbg;
        this.dwarf = dwarf;
        this.use1ByteBeforeToLookup = use1ByteBeforeToLookup;
    }

    public Address sp() {
        return sp;
    }

    public Address fp() {
        return fp;
    }

    public Address cfa() {
        return cfa;
    }

    public Address pc() {
        return pc;
    }

    public LinuxDebugger linuxDbg() {
        return linuxDbg;
    }

    public DwarfParser dwarf() {
        return dwarf;
    }

    // override base class impl to avoid ELF parsing
    @Override
    public ClosestSymbol closestSymbolToPC() {
        Address symAddr = use1ByteBeforeToLookup ? pc.addOffsetTo(-1) : pc;
        var sym = linuxDbg.lookup(linuxDbg.getAddressValue(symAddr));

        // Returns a special symbol if the address is signal trampoline,
        // otherwise returns closest symbol generated by LinuxDebugger.
        return linuxDbg.isSignalTrampoline(symAddr)
            ? new ClosestSymbol(sym.getName() + " <signal trampoline>", 0)
            : sym;
    }

    @Override
    public Address localVariableBase() {
        return (dwarf != null && dwarf.isBPOffsetAvailable())
            ? cfa.addOffsetTo(dwarf.getBasePointerOffsetFromCFA())
            : fp;
    }

    protected boolean isValidFrame(Address senderCFA, Address senderFP) {
        // Both CFA and FP must not be null.
        if (senderCFA == null && senderFP == null) {
            return false;
        }

        // FP must not be null if CFA is null - it happens between Java frame and Native frame.
        // We cannot validate FP value because it might be used as GPR. Thus returns true
        // if FP is not null.
        if (senderCFA == null && senderFP != null) {
            return true;
        }

        // senderCFA must be greater than current CFA.
        if (senderCFA != null && senderCFA.greaterThanOrEqual(cfa)) {
            return true;
        }

        // Otherwise, the frame is not valid.
        return false;
    }

    protected Address getSenderPC(Address senderPC) {
        if (senderPC != null) {
            return senderPC;
        }

        try {
            return dwarf == null
                ? fp.getAddressAt(VM.getVM().getAddressSize()) // Current frame is Java
                : cfa.getAddressAt(dwarf.getReturnAddressOffsetFromCFA()); // current frame is Native
        } catch (UnmappedAddressException | UnalignedAddressException _) {
            // Sender PC is invalid - maybe bottom of stack
            return null;
        }
    }

    protected Address getSenderSP(Address senderSP) {
        if (senderSP != null) {
            return senderSP;
        } else if (dwarf == null) {
            // Current frame is Java - skip saved BP and RA
            return fp.addOffsetTo(2 * VM.getVM().getAddressSize());
        } else {
            // Current frame is Native
            // CFA points SP at the call site in the previous frame.
            // See 6.4 Call Frame Information in DWARF Debugging Information Format
            //   https://dwarfstd.org/dwarf4std.html
            return cfa;
        }
    }

    protected Address getSenderFP(Address senderFP) {
        if (senderFP != null) {
            return senderFP;
        } else if (dwarf == null) { // Current frame is Java
            return fp.getAddressAt(0);
        } else { // Current frame is Native
            return dwarf.isBPOffsetAvailable()
                ? cfa.getAddressAt(dwarf.getBasePointerOffsetFromCFA())
                : fp;
        }
    }

    @Override
    public CFrame sender(ThreadProxy th) {
        return sender(th, null, null, null);
    }

}
